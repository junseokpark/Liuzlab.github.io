name: PR Sanity Check

on:
  pull_request_target:
    types: [opened, synchronize, reopened]
    branches: [ main ]

permissions:
  contents: read
  pull-requests: write

jobs:
  sanity-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout base branch
        uses: actions/checkout@v4

      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          path: pr-head

      - name: Get changed files
        id: changed-files
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              per_page: 100,
            });
            const filenames = files.map(f => f.filename);
            core.setOutput('files', JSON.stringify(filenames));
            core.info(`Changed files: ${filenames.join(', ')}`);

      - name: Run sanity checks
        id: sanity
        shell: bash
        env:
          CHANGED_FILES: ${{ steps.changed-files.outputs.files }}
        run: |
          errors=""
          warnings=""
          checked=0

          cd pr-head

          for file in $(echo "$CHANGED_FILES" | jq -r '.[]'); do
            # --------------------------------------------------
            # Check 1: Markdown frontmatter has closing delimiter
            # --------------------------------------------------
            if [[ "$file" == src/content/*.md || "$file" == src/content/*.mdx ]]; then
              checked=$((checked + 1))
              if [ ! -f "$file" ]; then
                # File was deleted in the PR ‚Äì nothing to validate
                continue
              fi

              # Verify the file starts with --- and has a closing ---
              if ! head -1 "$file" | grep -q '^---'; then
                errors="${errors}‚ùå \`${file}\`: Missing frontmatter delimiter (\`---\`) at start of file.\n"
                continue
              fi
              # Count --- lines; need at least 2 for valid frontmatter
              delimiter_count=$(grep -c '^---$' "$file" || true)
              if [ "$delimiter_count" -lt 2 ]; then
                errors="${errors}‚ùå \`${file}\`: Frontmatter is not properly closed (missing closing \`---\`).\n"
                continue
              fi

              # Extract frontmatter (between first and second ---)
              frontmatter=$(sed -n '/^---$/,/^---$/p' "$file" | sed '1d;$d')

              # --------------------------------------------------
              # Check 2: Required fields per collection
              # --------------------------------------------------
              dir=$(dirname "$file")
              collection=$(echo "$dir" | sed 's|src/content/||' | cut -d'/' -f1)

              case "$collection" in
                team)
                  for field in name role avatar; do
                    if ! echo "$frontmatter" | grep -q "^${field}:"; then
                      errors="${errors}‚ùå \`${file}\`: Missing required field \`${field}\` in frontmatter.\n"
                    fi
                  done
                  # Validate role value
                  if echo "$frontmatter" | grep -q '^role:'; then
                    role_value=$(echo "$frontmatter" | grep '^role:' | sed 's/^role: *"\{0,1\}\([^"]*\)"\{0,1\}/\1/')
                    valid_roles="Principal Investigator|Professor|Associate Professor|Assistant Professor|Postdoc|Research Assistant|PhD Student|Master Student|Undergraduate|Alumni"
                    if ! echo "$role_value" | grep -qE "^(${valid_roles})$"; then
                      errors="${errors}‚ùå \`${file}\`: Invalid role \`${role_value}\`. Must be one of: ${valid_roles//|/, }.\n"
                    fi
                  fi
                  ;;
                publications|books)
                  for field in title authors year venue; do
                    if ! echo "$frontmatter" | grep -q "^${field}:"; then
                      errors="${errors}‚ùå \`${file}\`: Missing required field \`${field}\` in frontmatter.\n"
                    fi
                  done
                  ;;
                news)
                  for field in title date; do
                    if ! echo "$frontmatter" | grep -q "^${field}:"; then
                      errors="${errors}‚ùå \`${file}\`: Missing required field \`${field}\` in frontmatter.\n"
                    fi
                  done
                  ;;
                research)
                  for field in title description; do
                    if ! echo "$frontmatter" | grep -q "^${field}:"; then
                      errors="${errors}‚ùå \`${file}\`: Missing required field \`${field}\` in frontmatter.\n"
                    fi
                  done
                  ;;
                softwares)
                  for field in title developers link date; do
                    if ! echo "$frontmatter" | grep -q "^${field}:"; then
                      errors="${errors}‚ùå \`${file}\`: Missing required field \`${field}\` in frontmatter.\n"
                    fi
                  done
                  ;;
                grants)
                  for field in title pis number startDate endDate status; do
                    if ! echo "$frontmatter" | grep -q "^${field}:"; then
                      errors="${errors}‚ùå \`${file}\`: Missing required field \`${field}\` in frontmatter.\n"
                    fi
                  done
                  ;;
                honors)
                  for field in title award date year type members; do
                    if ! echo "$frontmatter" | grep -q "^${field}:"; then
                      errors="${errors}‚ùå \`${file}\`: Missing required field \`${field}\` in frontmatter.\n"
                    fi
                  done
                  ;;
                activities)
                  for field in title date; do
                    if ! echo "$frontmatter" | grep -q "^${field}:"; then
                      errors="${errors}‚ùå \`${file}\`: Missing required field \`${field}\` in frontmatter.\n"
                    fi
                  done
                  ;;
                alumni)
                  for field in name previousPosition years currentPosition; do
                    if ! echo "$frontmatter" | grep -q "^${field}:"; then
                      errors="${errors}‚ùå \`${file}\`: Missing required field \`${field}\` in frontmatter.\n"
                    fi
                  done
                  ;;
              esac

              # --------------------------------------------------
              # Check 3: Image references exist
              # --------------------------------------------------
              image_refs=$(echo "$frontmatter" | grep -oE '("|'"'"'|)\.\./(\.\./)?assets/[^"'"'"'[:space:]]+("|'"'"'|)' | tr -d "\"'" || true)
              if [ -n "$image_refs" ]; then
                while IFS= read -r img_ref; do
                  # Resolve relative to the markdown file's directory
                  img_path=$(cd "$(dirname "$file")" && realpath -m "$img_ref" 2>/dev/null || echo "")
                  if [ -z "$img_path" ] || [ ! -f "$img_path" ]; then
                    errors="${errors}‚ùå \`${file}\`: Referenced image \`${img_ref}\` does not exist.\n"
                  fi
                done <<< "$image_refs"
              fi
            fi

            # --------------------------------------------------
            # Check 4: Image files are valid
            # --------------------------------------------------
            if [[ "$file" == src/assets/*.jpg || "$file" == src/assets/*.jpeg || "$file" == src/assets/*.png || "$file" == src/assets/*.gif || "$file" == src/assets/*.webp || "$file" == src/assets/*.svg ]]; then
              checked=$((checked + 1))
              if [ -f "$file" ]; then
                filesize=$(stat -c%s "$file" 2>/dev/null || echo 0)
                # Warn if image is larger than 2MB
                if [ "$filesize" -gt 2097152 ]; then
                  warnings="${warnings}‚ö†Ô∏è \`${file}\`: Image is $(( filesize / 1048576 ))MB. Consider compressing to under 2MB for faster page loads.\n"
                fi
              fi
            fi
          done

          # Write outputs
          echo "checked=$checked" >> "$GITHUB_OUTPUT"

          if [ -n "$errors" ]; then
            # Write errors to a file to preserve newlines
            printf '%b' "$errors" > /tmp/sanity-errors.txt
            echo "status=failure" >> "$GITHUB_OUTPUT"
          elif [ -n "$warnings" ]; then
            printf '%b' "$warnings" > /tmp/sanity-warnings.txt
            echo "status=warning" >> "$GITHUB_OUTPUT"
          else
            echo "status=success" >> "$GITHUB_OUTPUT"
          fi

      - name: Post sanity check results
        if: always()
        uses: actions/github-script@v7
        env:
          CHECK_STATUS: ${{ steps.sanity.outputs.status }}
          CHECKED_COUNT: ${{ steps.sanity.outputs.checked }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const prNumber = context.payload.pull_request.number;
            const runId = context.runId;
            const repo = context.repo;
            const status = process.env.CHECK_STATUS || 'success';
            const checked = process.env.CHECKED_COUNT || '0';

            let comment = '';

            if (status === 'failure') {
              let errors = '';
              try {
                errors = fs.readFileSync('/tmp/sanity-errors.txt', 'utf8');
              } catch (e) {
                errors = 'Could not read error details.';
              }
              comment = `‚ùå **Sanity Check Failed**

            The following issues were found in your PR:

            ${errors}

            üîó **Workflow Run:** [View Details](https://github.com/${repo.owner}/${repo.repo}/actions/runs/${runId})

            Please fix the errors above and push your changes.`;
            } else if (status === 'warning') {
              let warnings = '';
              try {
                warnings = fs.readFileSync('/tmp/sanity-warnings.txt', 'utf8');
              } catch (e) {
                warnings = '';
              }
              comment = `‚úÖ **Sanity Check Passed** (with warnings)

            All ${checked} checked file(s) passed validation.

            ${warnings}

            üîó **Workflow Run:** [View Details](https://github.com/${repo.owner}/${repo.repo}/actions/runs/${runId})`;
            } else {
              comment = `‚úÖ **Sanity Check Passed**

            All ${checked} checked file(s) passed validation.

            üîó **Workflow Run:** [View Details](https://github.com/${repo.owner}/${repo.repo}/actions/runs/${runId})`;
            }

            // Find and update or create bot comment
            try {
              const { data: comments } = await github.rest.issues.listComments({
                owner: repo.owner,
                repo: repo.repo,
                issue_number: prNumber,
              });

              const botComment = comments.find(c =>
                c.user.type === 'Bot' &&
                (c.body.includes('Sanity Check Passed') || c.body.includes('Sanity Check Failed'))
              );

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: repo.owner,
                  repo: repo.repo,
                  comment_id: botComment.id,
                  body: comment
                });
              } else {
                await github.rest.issues.createComment({
                  owner: repo.owner,
                  repo: repo.repo,
                  issue_number: prNumber,
                  body: comment
                });
              }
            } catch (e) {
              core.warning(`Could not post PR comment: ${e.message}`);
            }

      - name: Fail if sanity checks failed
        if: steps.sanity.outputs.status == 'failure'
        run: |
          echo "Sanity checks failed. See the PR comment or workflow log for details."
          exit 1
